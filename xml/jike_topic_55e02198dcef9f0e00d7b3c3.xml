<?xml version="1.0" encoding="UTF-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>JitHub程序员 - 即刻圈子</title><link>https://m.okjike.com/topics/55e02198dcef9f0e00d7b3c3</link><atom:link href="http://rsshub.rssforever.com/jike/topic/55e02198dcef9f0e00d7b3c3" rel="self" type="application/rss+xml"></atom:link><description>开发者们分享，问答，也可以交友的地方。欢迎所有工程师！ - Powered by RSSHub</description><generator>RSSHub</generator><webMaster>contact@rsshub.app (RSSHub)</webMaster><language>en</language><image><url>https://cdnv2.ruguoapp.com/FkFcHSgyNRo4yKxLYMVbDDP6gwdk.png?imageMogr2/auto-orient/heic-exif/1/format/jpeg/thumbnail/1000x1000%3E</url><title>JitHub程序员 - 即刻圈子</title><link>https://m.okjike.com/topics/55e02198dcef9f0e00d7b3c3</link></image><lastBuildDate>Fri, 25 Jul 2025 20:12:23 GMT</lastBuildDate><ttl>5</ttl><item><title>Startup福音！ ProductHunt 给用户免费提供一年的.tech域名！无需绑卡，无任何隐藏费用，无附加条款，可以转移，填一下表格就能申请了！ 申请地址：https://prod...</title><description>Startup福音！&lt;br&gt;&lt;br&gt;ProductHunt 给用户免费提供一年的.tech域名！无需绑卡，无任何隐藏费用，无附加条款，可以转移，填一下表格就能申请了！&lt;br&gt;&lt;br&gt;申请地址：https://producthunt.get.tech/&lt;br&gt;&lt;img src=&quot;https://cdnv2.ruguoapp.com/Fs2Bbf5RKlNOQ-74h2CI383CNoBIv3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cdnv2.ruguoapp.com/FocHi-aJJiBdkQCzfBpuWgwi5FH4v3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cdnv2.ruguoapp.com/FuNBbKNv6cOeD-YqWYW7TS5QOFsDv3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;</description><link>https://m.okjike.com/originalPosts/68835800476384a01e2d40ae</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/68835800476384a01e2d40ae</guid><pubDate>Fri, 25 Jul 2025 10:10:08 GMT</pubDate><author>小邱很行</author></item><item><title>还是拿果园种树来举例，程序员是给果园老板种树的，拿到手的是辛苦费，并不享受果树结果后的果实收益。 你亲手敲出来的代码，你双手创造出来的作品，并不是你的...</title><description>还是拿果园种树来举例，程序员是给果园老板种树的，拿到手的是辛苦费，并不享受果树结果后的果实收益。&lt;br&gt;你亲手敲出来的代码，你双手创造出来的作品，并不是你的，你没有所有权，于是也就没办法传给下一代。&lt;br&gt;但如果你给自己种下了一片果园，那就可以传家了。&lt;br&gt;&lt;img src=&quot;https://cdnv2.ruguoapp.com/FrAm0JSWIeZJwMkRIj6zU21cQF3Xv3.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cdnv2.ruguoapp.com/FjZGVYWd61AIS5vyviy5Z3ov3JQ9v3.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://cdnv2.ruguoapp.com/FqHeGvOjm3Ne6JW8HhU_wPFb1cJav3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;</description><link>https://m.okjike.com/originalPosts/68831c12003901b635eb3900</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/68831c12003901b635eb3900</guid><pubDate>Fri, 25 Jul 2025 05:54:26 GMT</pubDate><author>哥飞</author></item><item><title>又踩了Unity一个坑：InputSystem的SwitchProControllerHID是给Windows平台下的NSPro手柄用的。 真正编译NS包时，这玩意要用宏隔离掉🙄</title><description>又踩了Unity一个坑：InputSystem的SwitchProControllerHID是给Windows平台下的NSPro手柄用的。&lt;br&gt;真正编译NS包时，这玩意要用宏隔离掉🙄</description><link>https://m.okjike.com/originalPosts/688259120232bb9de55fb0a4</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/688259120232bb9de55fb0a4</guid><pubDate>Thu, 24 Jul 2025 16:02:26 GMT</pubDate><author>杰克有茶</author></item><item><title>Vibe coding 现状： 卖课的/自媒体：太强了，没有我开发不了的软件！ 程序员：艹，还不如我自己写！</title><description>Vibe  coding  现状：&lt;br&gt;卖课的/自媒体：太强了，没有我开发不了的软件！&lt;br&gt;程序员：艹，还不如我自己写！</description><link>https://m.okjike.com/originalPosts/688238097ee613ba5adfc55a</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/688238097ee613ba5adfc55a</guid><pubDate>Thu, 24 Jul 2025 13:41:29 GMT</pubDate><author>dangjin</author></item><item><title>分享一个我平时开发用的 Prompt： ## 需求分析与拆分 1. **优先理解需求**：在开始编码前，深入分析并全理解业务需求和用户期望。 2. **拆分子需求**：将复杂需...</title><description>分享一个我平时开发用的 Prompt：&lt;br&gt;&lt;br&gt;## 需求分析与拆分&lt;br&gt;&lt;br&gt;1. **优先理解需求**：在开始编码前，深入分析并全理解业务需求和用户期望。&lt;br&gt;2. **拆分子需求**：将复杂需求拆分为可管理的子需求，使得开发过程更加高效，减少返工。&lt;br&gt;3. **拆解出项目结构**：根据理解的需求拆解项目结构和文件。&lt;br&gt;&lt;br&gt;## 基于设计原则&lt;br&gt;1. **SOLID 原则**：确保组件设计符合单一职责原则和其他 SOLID 原则。&lt;br&gt;2. **DRY 原则（Don&#39;t Repeat Yourself）**：通过提取和重用代码，避免重复。&lt;br&gt;3. **可复用性**：设计组件时考虑其在不同上下文中的重用性。&lt;br&gt;4. **可扩展性**：保证组件的结构能够轻松应对未来功能的扩展。&lt;br&gt;&lt;br&gt;## 组件封装方式&lt;br&gt;1. **组件化设计**：将 UI 和逻辑分离，创建可复用的组件。&lt;br&gt;2. **功能组件**：每个组件应专注于单一功能，避免过于复杂的逻辑。&lt;br&gt;3. **Hooks 和纯函数组件**：使用函数组件和 React Hooks 简化逻辑，避免不必要复杂性。&lt;br&gt;4. **组合优于继承** ：通过组合而非继承来实现组件的复用和扩展。&lt;br&gt;5. **组件文件名称**：使用小写字母，- 分割，例如：generate-history-grid.tsx&lt;br&gt;6. **使用ES6**：严格使用ES6 和 箭头函数定义组件和方法。&lt;br&gt;7. **组件格式**：&lt;br&gt;```TypeScript&lt;br&gt;import React from &quot;react&quot;;&lt;br&gt;const Name: React.FC = () =&amp;gt; {&lt;br&gt;  return &amp;lt;&amp;gt;Name;&lt;br&gt;};&lt;br&gt;&lt;br&gt;Name.displayName = &quot;Name&quot;;&lt;br&gt;&lt;br&gt;export default Name;&lt;br&gt;```&lt;br&gt;&lt;br&gt;  &lt;br&gt;## 状态管理&lt;br&gt;1. **状态提升**：在多个组件需要共享状态时，将状态提升至最近公共父组件。&lt;br&gt;2. **状态最小化**：保持状态简单不可变，确定最小必需状态。&lt;br&gt;3. **单一数据源**：确保有一个权威的数据源，减少冲突问题。&lt;br&gt;4. **Prop 数据传递**：通过 Props 传递数据，保持单向数据流。&lt;br&gt;5. **Hooks 使用**：多使用 Hooks（如 useState, useReducer）进行状态和副作用管理。&lt;br&gt;6. **状态生命周期理解**：严格遵循 React 生命周期最佳实践。&lt;br&gt;7. **副作用管理**：使用 useEffect 和 useLayoutEffect 管理副作用。&lt;br&gt;&lt;br&gt;## 全局状态管理&lt;br&gt;1. **使用 Jotai**：使用 Jotai 作为全局状态管理解决方案，简化状态共享和管理。&lt;br&gt;2. **Atom 和 Selector**：使用 Atom 定义状态，Selector 计算派生状态。&lt;br&gt;3. **原子化状态**：将全局状态拆分为多个小的原子状态，便于管理和更新。&lt;br&gt;4. **避免全局状态污染**：&lt;br&gt;- 确保全局状态只包含必要的数据，避免过度依赖全局状态。&lt;br&gt;- 使用局部状态代替全局状态，除非确实需要跨组件共享数据。&lt;br&gt;5. **状态更新**：使用 Jotai 提供的 `useAtom` 钩子进行状态更新，确保组件在状态变化时正确重新渲染。&lt;br&gt;6. **性能优化**：使用 Jotai 的 `useAtomValue` 钩子获取状态值，避免不必要的重新渲染。&lt;br&gt;&lt;br&gt;  &lt;br&gt;&lt;br&gt;## 错误处理&lt;br&gt;1. **异常捕获**&lt;br&gt;2. **Error Boundary**：使用 Error Boundary 捕获并处理渲染异常。&lt;br&gt;3. **异步操作错误**：为异步请求设置适当的错误处理机制。&lt;br&gt;&lt;br&gt;  &lt;br&gt;## 类型安全&lt;br&gt;1. **TypeScript 强类型**：推广使用 TypeScript，启用严格模式保证类型安全。&lt;br&gt;2. **避免使用 any**：减少或避免使用 any 类型，使用更具体的类型定义。&lt;br&gt;3. **处理空值**：在代码中妥善处理可能的空值或未定义情况。&lt;br&gt;&lt;br&gt;  &lt;br&gt;&lt;br&gt;## 样式管理&lt;br&gt;1. **使用 Tailwind CSS**：使用 Tailwind CSS 进行样式管理，确保样式一致性和可维护性。&lt;br&gt;2. **最小粒度的组件化**：将样式应用到最小可用组件，提高重用性。&lt;br&gt;3. **使用 framer-motion 动画效果**：为组件添加动画，提高用户体验。&lt;br&gt;&lt;br&gt;## 渲染优化&lt;br&gt;1. **性能优化**：通过 React.memo、useMemo、useCallback 等技术优化性能，避免不必要的重新渲染。&lt;br&gt;2. **懒加载**：使用 React.lazy 和 Suspense 实现组件懒加载，提升初始加载速度。&lt;br&gt;3. **虚拟化列表**：对于长列表，使用 react-window 或 react-virtualized 实现虚拟化，提升渲染性能。&lt;br&gt;&lt;br&gt;## 文档规范&lt;br&gt;1. **注释规范**&lt;br&gt;- **复杂逻辑注释**：解释复杂逻辑，帮助其他开发者理解。&lt;br&gt;- **JSDoc 标注**：为函数和组件添加详细的 JSDoc 文档。&lt;br&gt;  &lt;br&gt;2. **文档撰写**&lt;br&gt;- **组件说明书**：编写组件功能、依赖、输入和输出文档。&lt;br&gt;- **版本变更说明**：记录重要更新和 API 变更。&lt;br&gt;&lt;br&gt;  &lt;br&gt;## 命令&lt;br&gt;1. 始终使用 pnpm 命令。&lt;br&gt;2. 使用 Shadcn-ui 时，命令为：pnpm dlx shadcn@Latest xxxx&lt;br&gt;&lt;br&gt;## 网络请求&lt;br&gt;1. **使用 SWR**：使用 SWR 进行网络请求，确保请求和响应的类型安全。&lt;br&gt;2. **错误处理**：为网络请求添加错误处理逻辑，确保用户体验。&lt;br&gt;3. **缓存策略**：合理配置 SWR 的缓存策略，减少不必要的网络请求。&lt;br&gt;4. **数据获取**：使用 SWR 的 `useSWR` 钩子获取数据，确保数据的实时性和一致性。&lt;br&gt;5. **请求参数**：确保请求参数类型安全，避免使用 any 类型。&lt;br&gt;6. **响应处理**：对响应数据进行类型检查和处理，确保数据的。&lt;br&gt;  &lt;br&gt;&lt;br&gt;## 其他说明&lt;br&gt;1. 网页内容语言始终使用英语，代码注释可以使用中文。&lt;br&gt;2. 组件和文件命名使用小写字母，- 分割。&lt;br&gt;3. 确保代码风格一致，遵循团队约定的代码规范。&lt;br&gt;4. 在 import 的时候，始终使用 @ 别名。&lt;br&gt;&lt;br&gt;## 目录结构&lt;br&gt;```&lt;br&gt;/my-app&lt;br&gt;├── public/                         # 静态资源目录（favicon、图像等）&lt;br&gt;│   └── images/&lt;br&gt;│       └── logo.png&lt;br&gt;│&lt;br&gt;├── src/                            # 源代码目录&lt;br&gt;│   ├── app/                        # App Router 页面结构&lt;br&gt;│   │   ├── layout.tsx             # 全局布局（Header/Footer）&lt;br&gt;│   │   ├── page.tsx               # 主页（/）&lt;br&gt;│   │   ├── about/page.tsx         # 静态页面（/about）&lt;br&gt;│   │   ├── blog/[slug]/page.tsx   # 动态页面（如 /blog/hello-world）&lt;br&gt;│   │   └── api/                   # API routes（/api/...）&lt;br&gt;│   │       └── ping/route.ts&lt;br&gt;│   │&lt;br&gt;│   ├── components/                # 组件目录（结构清晰、按功能分类）&lt;br&gt;│   │   ├── layout/                # 页面结构组件&lt;br&gt;│   │   │   ├── header.tsx&lt;br&gt;│   │   │   └── footer.tsx&lt;br&gt;│   │   ├── ui/                    # 原子 UI 组件（按钮、输入框等）&lt;br&gt;│   │   │   ├── button.tsx&lt;br&gt;│   │   │   └── input.tsx&lt;br&gt;│   │   ├── shared/                # 可复用功能性组件（如 PostCard、CardList）&lt;br&gt;│   │   │   └── post-card.tsx&lt;br&gt;│   │   └── seo/                   # SEO Head 组件&lt;br&gt;│   │       └── seo-head.tsx&lt;br&gt;│   │&lt;br&gt;│   ├── hooks/                     # 自定义 React Hooks&lt;br&gt;│   │   ├── use-search.ts&lt;br&gt;│   │   └── use-responsive.ts&lt;br&gt;│   │&lt;br&gt;│   ├── lib/                       # 工具函数 / 逻辑封装（fetch、markdown、缓存等）&lt;br&gt;│   │   ├── api.ts&lt;br&gt;│   │   ├── markdown.ts&lt;br&gt;│   │   └── constants.ts&lt;br&gt;│   │&lt;br&gt;│   ├── types/                     # 类型定义&lt;br&gt;│   │   ├── post.ts&lt;br&gt;│   │   └── index.ts&lt;br&gt;│   │&lt;br&gt;│   ├── data/                      # 静态数据（JSON、MDX、YAML）&lt;br&gt;│   │   ├── posts/&lt;br&gt;│   │   │   └── hello-world.md&lt;br&gt;│   │   └── site-config.json&lt;br&gt;│   │&lt;br&gt;│   ├── styles/                    # 样式文件（支持 Tailwind / SCSS / CSS Modules）&lt;br&gt;│   │   ├── globals.css&lt;br&gt;│   │   └── theme.css&lt;br&gt;│   │&lt;br&gt;│   └── middleware.ts              # Next.js 中间件（可选）&lt;br&gt;│&lt;br&gt;├── .env.local                     # 环境变量&lt;br&gt;├── next.config.js                 # Next.js 配置&lt;br&gt;├── tailwind.config.ts            # Tailwind 配置（如使用）&lt;br&gt;├── tsconfig.json                  # TypeScript 配置&lt;br&gt;└── README.md&lt;br&gt;```</description><link>https://m.okjike.com/originalPosts/68821fada9ac2254443ed497</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/68821fada9ac2254443ed497</guid><pubDate>Thu, 24 Jul 2025 11:57:33 GMT</pubDate><author>ReAvid</author></item><item><title># 🔥 Claude Code 一周热榜：开发者都在玩什么新花样？ 刚刚扫了一圈 GitHub，发现最近一周 Claude Code 的生态简直爆炸了！440 个新项目，个个都有意思。挑了...</title><description># 🔥 Claude Code 一周热榜：开发者都在玩什么新花样？&lt;br&gt;&lt;br&gt;刚刚扫了一圈 GitHub，发现最近一周 Claude Code 的生态简直爆炸了！440 个新项目，个个都有意思。挑了 20 个最 🔥 的跟大家分享～&lt;br&gt;&lt;br&gt;## 🚀 最让人眼前一亮的项目&lt;br&gt;&lt;br&gt;### 📱 移动端来了！&lt;br&gt;**[Happy Coder](https://github.com/slopus/happy)** - 终于有人做了移动版 Claude Code 客户端！再也不用守着电脑敲代码了，地铁上也能 Vibe Coding 😎&lt;br&gt;&lt;br&gt;**[Clauder](https://github.com/ZohaibAhmed/clauder)** - 更狠，直接用 iPhone 远程控制桌面的 Claude Code，躺床上写代码不是梦 🛌&lt;br&gt;&lt;br&gt;### 🦀 Rust 党狂欢&lt;br&gt;**[claude-code-api-rs](https://github.com/ZhangHanDong/claude-code-api-rs)** - 高性能 Rust 实现的 API 网关，OpenAI 兼容，性能怪兽 ⚡&lt;br&gt;&lt;br&gt;**[cc-monitor-rs](https://github.com/ZhangHanDong/cc-monitor-rs)** - 实时监控 Claude Code 使用情况，用了 Makepad 做原生 UI，颜值在线 📊&lt;br&gt;&lt;br&gt;### 🔧 工作流神器&lt;br&gt;**[claude-code-spec-workflow](https://github.com/Pimzino/claude-code-spec-workflow)** - 把&quot;需求→设计→任务→实现&quot;整个流程自动化了，再也不怕需求变更 📋&lt;br&gt;&lt;br&gt;**[Kiro Claude Code](https://github.com/stillfox-lee/kiro-claude-code)** - 像有个技术经理坐在旁边，帮你梳理需求、设计方案、制定计划，Context Engineering 的最佳实践 🧠&lt;br&gt;&lt;br&gt;## 🛠 开发者必备工具箱&lt;br&gt;&lt;br&gt;- **[Claude-Code-Toolkit](https://github.com/xixu-me/Claude-Code-Toolkit)** - 跨平台管理工具，支持所有 Anthropic 兼容的 API，中英文都有&lt;br&gt;- **[Agent Toolbox](https://github.com/czottmann/agent-toolbox)** - 命令、规则、设置一应俱全，还能和 Gemini 互操作&lt;br&gt;- **[claude_commands](https://github.com/EveryInc/claude_commands)** - EveryInc 团队精选的命令集合，专业团队出品&lt;br&gt;- **[claude-code-settings](https://github.com/feiskyer/claude-code-settings)** - 流畅编码体验的配置优化&lt;br&gt;&lt;br&gt;## 🌐 多语言生态爆发&lt;br&gt;&lt;br&gt;- **[PHP SDK](https://github.com/HelgeSverre/claude-code-sdk-php)** - PHP 开发者终于有官方支持了&lt;br&gt;- **[TypeScript Hooks](https://github.com/bartolli/claude-code-typescript-hooks)** - 前端同学的专属工具&lt;br&gt;- **[DashScope 配置](https://github.com/dashscope/claude-code-config)** - 阿里云生态接入&lt;br&gt;&lt;br&gt;## 🔮 有趣的实验项目&lt;br&gt;&lt;br&gt;**[Lovelace IDE](https://github.com/adacahq/lovelace-ide)** - 基于 VS Code，原生集成 Claude Code，IDE 和 AI 的完美融合&lt;br&gt;&lt;br&gt;**[Pix Canvas](https://github.com/hmldns/pix-canvas)** - 多人实时像素画布，用 WebRTC + Claude 驱动，AI 开发的最佳演示&lt;br&gt;&lt;br&gt;**[claude-code-open](https://github.com/Davincible/claude-code-open)** - 支持 OpenRouter、Gemini、Kimi K2 等多个 LLM 提供商，选择恐惧症福音&lt;br&gt;&lt;br&gt;## 💡 趋势观察&lt;br&gt;&lt;br&gt;看这一波项目，几个明显的趋势：&lt;br&gt;&lt;br&gt;1. **移动化** - 大家开始把 AI 编程搬到手机上了&lt;br&gt;2. **工作流化** - 不只是写代码，而是整个开发流程的重新设计&lt;br&gt;3. **多语言** - 不只是 Python/JS</description><link>https://m.okjike.com/originalPosts/688182f3d2084fb6d9c6cbfa</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/688182f3d2084fb6d9c6cbfa</guid><pubDate>Thu, 24 Jul 2025 00:48:51 GMT</pubDate><author>风哥-全栈ai工程师</author></item><item><title>最近带一个实习生，给了他一个不算复杂的小项目，前后端加点部署。我本来很开心，觉得他能趁这个机会，把一个完整的项目从 0 跑通，对工程能力是很好的锻炼。 他...</title><description>最近带一个实习生，给了他一个不算复杂的小项目，前后端加点部署。我本来很开心，觉得他能趁这个机会，把一个完整的项目从 0 跑通，对工程能力是很好的锻炼。&lt;br&gt;&lt;br&gt;他是学计算机的，我知道学校里更多教的是理论，真正实战的经验还是要靠项目来补。也正是因为这样，我更希望他能通过这个任务，真正学点东西。&lt;br&gt;&lt;br&gt;结果他一上来就直接让llm 写代码，demo 很快跑出来了，界面看着也“像那么回事”。但一看细节，全是 bug，还有很多edge cases 完全不考虑。我问他为什么逻辑这么设计，他也很直白：“我也不清楚，是 llm 写的。”&lt;br&gt;&lt;br&gt;我当时有点沉默，说不出是失望还是担心。最后我只能帮他从头把代码一行行捋一遍，才勉强交付。还好项目够小，重写不算太难。&lt;br&gt;&lt;br&gt;我不是反对用 AI 写代码，相反我自己也在用。但我一直相信：工具是辅助，不是替代；理解是根本，而不是跳过。&lt;br&gt;&lt;br&gt;LLM 可以提高效率，但它不能替我们成长。如果一上来就把整个逻辑交给模型，最后连自己写了什么都搞不懂，那我们永远都不会是那个能独立完成项目的人。&lt;br&gt;&lt;br&gt;我不是在批评这个实习生——他是个聪明的同学。我只是突然意识到，也许我们正身处一个危险的习惯转折点：&lt;br&gt;&lt;br&gt;年轻工程师太早依赖模型，而不愿花时间理解代码背后的结构与逻辑。这，真的很危险。&lt;br&gt;&lt;br&gt;总结一下思考吧，也算是共勉，毕竟现在技术更新很快，每个人在某些地方都会是新手：&lt;br&gt;· AI 的强大不应该成为“偷懒”的理由，而是应该成为我们加深思考的辅助；&lt;br&gt;· Vibe coding 也要看修改了什么代码，如果是不熟悉的语言，也要尝试去理解，让模型解释，久而久之就能理解了&lt;br&gt;· 成长一定是“痛感 +打磨”的结合，模型不能替代这两个部分。</description><link>https://m.okjike.com/originalPosts/6880c88b7ee613ba5ac71062</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/6880c88b7ee613ba5ac71062</guid><pubDate>Wed, 23 Jul 2025 11:33:31 GMT</pubDate><author>Liz_Li</author></item><item><title>最近和朋友聊天，多次表达过一个观点： 当国内大模型，从编程角度，模型的效果只要实打实的追平 claude 3.7以上(因为3.7之后我没有一行完整的代码是自己手码的)...</title><description>最近和朋友聊天，多次表达过一个观点：&lt;br&gt;当国内大模型，从编程角度，模型的效果只要实打实的追平 claude 3.7以上(因为3.7之后我没有一行完整的代码是自己手码的)，那么程序员的裁员大潮就开始了，裁员速度随着时间应该是指数性的。</description><link>https://m.okjike.com/originalPosts/688046c16ad01e0258a694cc</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/688046c16ad01e0258a694cc</guid><pubDate>Wed, 23 Jul 2025 02:19:45 GMT</pubDate><author>凯祭恩Kaijien</author></item><item><title>小小的小宇宙SDK Python版 吸取了Jike-Metro的一些经验，更快更易拓展。</title><description>&lt;img src=&quot;https://cdnv2.ruguoapp.com/icons/link.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;            &lt;a href=&quot;https://github.com/Sorosliu1029/cosmos-wormhole&quot;&gt;https://github.com/Sorosliu1029/cosmos-wormhole&lt;/a&gt;&lt;br&gt;        &lt;br&gt;小小的小宇宙SDK Python版&lt;br&gt;&lt;br&gt;吸取了Jike-Metro的一些经验，更快更易拓展。</description><link>https://m.okjike.com/originalPosts/687f533ff564a21d70dd87f0</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/687f533ff564a21d70dd87f0</guid><pubDate>Tue, 22 Jul 2025 09:00:47 GMT</pubDate><author>刘-_-勋-..-阳</author></item><item><title>分享一个最近 Vibe Coding 的方法，简单有效： 1. 在 Gemini CLI 里，先输入一句：我不需要你直接修改文件和函数，我希望你指出需要修改的函数，以及提供修改后...</title><description>分享一个最近 Vibe Coding 的方法，简单有效：&lt;br&gt;&lt;br&gt;1. 在 Gemini CLI 里，先输入一句：我不需要你直接修改文件和函数，我希望你指出需要修改的函数，以及提供修改后的版本，让我手动处理。&lt;br&gt;&lt;br&gt;2. 按照正常情景下，输入你希望 Gemini CLI 完成的任务。&lt;br&gt;&lt;br&gt;3. 将 Gemini CLI 回复的内容，复制到 Cursor，将模型调整到 Auto 模式。&lt;br&gt;&lt;br&gt;然后你就会发现，这个方式：&lt;br&gt;&lt;br&gt;- 避免了 Gemini CLI 脆弱的工具调用能力，和老是出现的 string error，无法找到文件中对应的部分进行修改的错误&lt;br&gt;&lt;br&gt;- 同时应用了Cursor 的 Auto 模式强大的发现代码，和工具调用的能力&lt;br&gt;&lt;br&gt;- 而且，还结合了 Gemini 强大的代码解读能力，超强上下文，以及强大的代码输出能力</description><link>https://m.okjike.com/originalPosts/687f51bcf564a21d70dd71b3</link><guid isPermaLink="false">https://m.okjike.com/originalPosts/687f51bcf564a21d70dd71b3</guid><pubDate>Tue, 22 Jul 2025 08:54:21 GMT</pubDate><author>Yibie</author></item></channel></rss>